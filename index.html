<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>自由图片拼接工具（背景模糊 + 无滤镜）</title>
  <style>
    /* 原有样式保持不变，略 */
    #bgBlurSlider { width: 120px; }
  </style>
</head>
<body>

<div id="toolbar">
  <button onclick="document.getElementById('file').click()">+ 添加图片</button>
  <input type="file" id="file" multiple accept="image/*" style="display:none"/>

  <button onclick="document.getElementById('bgFile').click()">+ 背景图</button>
  <input type="file" id="bgFile" accept="image/*" style="display:none"/>
  <button id="removeBgBtn" onclick="removeBackground()" style="display:none;">移除背景</button>

  <div class="control-group">
    <label>背景模糊：</label>
    <input type="range" id="bgBlurSlider" min="0" max="20" value="0" step="0.5">
    <span id="blurVal">0 px</span>
  </div>

  <button onclick="addTextLayer()">+ 文本</button>
  <button onclick="applySmartLayout()">AI 智能布局</button>
  <button onclick="applyNineGrid()">九宫格</button>
  <button onclick="autoArrange('row')">横向平铺</button>
  <button onclick="autoArrange('waterfall')">垂直瀑布</button>

  <div class="control-group"><label>间距</label><input type="range" id="spacing" min="0" max="80" value="30"><span id="spVal">30</span></div>
  <div class="control-group"><label>圆角</label><input type="range" id="radius" min="0" max="60" value="12"><span id="radVal">12</span></div>
  <div class="control-group"><button id="shadowBtn" onclick="toggleShadow()">阴影:开</button></div>
  <div class="control-group"><label>背景色</label><input type="color" id="bgColor" value="#f8f9fa"></div>

  <button onclick="resetAll()">重置</button>
  <button onclick="exportImage()">导出 PNG</button>
</div>

<!-- container 和 canvas-wrapper 保持不变 -->

<script>
// ==================== 新增全局变量 ====================
let bgBlurRadius = 0;
let backgroundImg = null;  // 背景图片 Image 对象

// ... 原有全局变量（layers, selected 等）保持不变 ...

// 背景模糊滑块事件
document.getElementById('bgBlurSlider').oninput = e => {
  bgBlurRadius = +e.target.value;
  document.getElementById('blurVal').textContent = bgBlurRadius;
  redrawBackground();
};

// 背景图上传
document.getElementById('bgFile').onchange = e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      backgroundImg = img;
      document.getElementById('removeBgBtn').style.display = 'inline-block';
      redrawBackground();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
};

// 移除背景
function removeBackground() {
  backgroundImg = null;
  document.getElementById('removeBgBtn').style.display = 'none';
  redrawBackground();
}

// 重绘背景（带模糊）
function redrawBackground() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (backgroundImg) {
    ctx.filter = `blur(${bgBlurRadius}px)`;
    
    // cover 模式：保持比例，居中裁剪填充
    const ratio = Math.max(canvas.width / backgroundImg.width, canvas.height / backgroundImg.height);
    const nw = backgroundImg.width * ratio;
    const nh = backgroundImg.height * ratio;
    const nx = (canvas.width - nw) / 2;
    const ny = (canvas.height - nh) / 2;

    ctx.drawImage(backgroundImg, nx, ny, nw, nh);
    
    // 恢复默认（防止影响前景层）
    ctx.filter = 'none';
  }
}

// 导出 PNG（先画模糊背景，再画前景层）
function exportImage() {
  const temp = document.createElement('canvas');
  temp.width = canvas.width;
  temp.height = canvas.height;
  const tctx = temp.getContext('2d');

  // 画背景色（兜底）
  tctx.fillStyle = bgColor;
  tctx.fillRect(0, 0, temp.width, temp.height);

  // 画模糊背景图（如果有）
  if (backgroundImg) {
    tctx.filter = `blur(${bgBlurRadius}px)`;
    const ratio = Math.max(temp.width / backgroundImg.width, temp.height / backgroundImg.height);
    const nw = backgroundImg.width * ratio;
    const nh = backgroundImg.height * ratio;
    const nx = (temp.width - nw) / 2;
    const ny = (temp.height - nh) / 2;
    tctx.drawImage(backgroundImg, nx, ny, nw, nh);
    tctx.filter = 'none';
  }

  // 画所有前景层（图片/文本）
  layers.forEach(layer => {
    const el = layer.el;
    const rect = el.getBoundingClientRect();
    const base = wrapper.getBoundingClientRect();
    const x = rect.left - base.left;
    const y = rect.top - base.top;
    const w = rect.width;
    const h = rect.height;

    tctx.save();
    tctx.translate(x + w/2, y + h/2);
    tctx.rotate(layer.rot * Math.PI / 180);
    tctx.scale(layer.flipH || 1, layer.flipV || 1);

    if (shadowOn) {
      tctx.shadowColor = 'rgba(0,0,0,0.3)';
      tctx.shadowBlur = 15;
      tctx.shadowOffsetY = 6;
    }

    if (radius > 0) {
      tctx.beginPath();
      tctx.roundRect(-w/2, -h/2, w, h, radius);
      tctx.clip();
    }

    if (layer.type === 'img') {
      tctx.drawImage(layer.img, -w/2, -h/2, w, h);
    } else if (layer.type === 'text') {
      tctx.fillStyle = el.style.color || '#000';
      tctx.font = `${parseFloat(el.style.fontSize || 20)}px sans-serif`;
      tctx.textAlign = 'center';
      tctx.textBaseline = 'middle';
      tctx.fillText(el.textContent, 0, 0);
    }

    tctx.restore();
  });

  const a = document.createElement('a');
  a.href = temp.toDataURL('image/png');
  a.download = '拼图_带模糊背景.png';
  a.click();
}

// 重置时清除背景相关
function resetAll() {
  layers = [];
  wrapper.querySelectorAll('.layer').forEach(el => el.remove());
  backgroundImg = null;
  document.getElementById('removeBgBtn').style.display = 'none';
  bgBlurRadius = 0;
  document.getElementById('bgBlurSlider').value = 0;
  document.getElementById('blurVal').textContent = 0;
  setSize(1400, 1000);
  selected = null;
  redrawBackground();
}

// ... 其余代码（添加图片、文本、AI布局、九宫格、拖拽、旋转、导出等）保持不变 ...
</script>
</body>
</html>
