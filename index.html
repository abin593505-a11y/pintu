<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>自由图片拼接工具（优化版 + 扩展功能）</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#f4f6f8; overflow:hidden; }
    #toolbar {
      position: fixed; top:0; left:0; right:0; height:80px;
      background:#fff; box-shadow:0 2px 10px rgba(0,0,0,0.1);
      display:flex; align-items:center; gap:14px; padding:0 16px;
      flex-wrap:wrap; z-index:100;
    }
    button, input, select { padding:6px 12px; border-radius:6px; border:1px solid #d0d0d0; }
    button { background:#409eff; color:white; border:none; cursor:pointer; }
    button:hover { background:#79bbff; }
    .control-group { display:flex; align-items:center; gap:8px; white-space:nowrap; }
    input[type="range"] { width:140px; }
    input[type="color"] { width:40px; height:30px; padding:2px; }
    #container { position:absolute; inset:80px 0 0 0; overflow:auto; background:#e9ecef; }
    #canvas-wrapper {
      position:relative; min-width:600px; min-height:400px;
      background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%),
                  linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%);
      background-size:30px 30px; box-shadow:0 0 20px rgba(0,0,0,0.15);
      margin:40px auto; transition:background-color 0.3s;
    }
    #canvas { position:absolute; top:0; left:0; pointer-events:none; }
    .resize-handle { 
      position: absolute;
      width: 16px; height: 16px;
      background: #409eff; border: 3px solid white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      z-index: 20;
    }
    #handle-t { top:-8px; left:50%; transform:translateX(-50%); cursor: ns-resize; }
    #handle-b { bottom:-8px; left:50%; transform:translateX(-50%); cursor: ns-resize; }
    #handle-l { left:-8px; top:50%; transform:translateY(-50%); cursor: ew-resize; }
    #handle-r { right:-8px; top:50%; transform:translateY(-50%); cursor: ew-resize; }
    #handle-tl { top:-8px; left:-8px; cursor: nwse-resize; }
    #handle-tr { top:-8px; right:-8px; cursor: nesw-resize; }
    #handle-bl { bottom:-8px; left:-8px; cursor: nesw-resize; }
    #handle-br { bottom:-8px; right:-8px; cursor: nwse-resize; }
    .layer {
      position:absolute; cursor:move; user-select:none; touch-action:none;
      transform-origin:center center; transition:all 0.15s ease;
    }
    .img-layer { box-shadow: 0 2px 8px rgba(0,0,0,0.12); }
    .text-layer { padding: 4px; border: 1px dashed #ccc; min-width: 50px; min-height: 20px; }
    .layer.selected { box-shadow:0 0 0 3px #409eff, 0 4px 12px rgba(0,0,0,0.25); outline: 2px dashed #79bbff; }
    .rotate-handle {
      position: absolute;
      top: -20px; left: 50%;
      transform: translateX(-50%);
      width: 24px; height: 24px;
      background: #409eff; border: 3px solid white;
      border-radius: 50%;
      cursor: grab;
      display: none;
      z-index: 10;
    }
    .layer.selected .rotate-handle { display: block; }
  </style>
</head>
<body>

<div id="toolbar">
  <button onclick="document.getElementById('file').click()">+ 添加图片</button>
  <input type="file" id="file" multiple accept="image/*" style="display:none"/>

  <button onclick="addTextLayer()">+ 添加文本</button>
  <button onclick="flipSelected('horizontal')">水平翻转</button>
  <button onclick="flipSelected('vertical')">垂直翻转</button>
  <select id="filterSelect" onchange="applyFilter(this.value)">
    <option value="none">无滤镜</option>
    <option value="grayscale(100%)">黑白</option>
    <option value="sepia(100%)">怀旧</option>
    <option value="invert(100%)">反色</option>
    <option value="brightness(150%)">增亮</option>
    <option value="contrast(150%)">增强对比</option>
  </select>

  <button onclick="applyNineGrid()">九宫格</button>
  <button onclick="autoArrange('row')">横向平铺</button>
  <button onclick="autoArrange('waterfall')">垂直瀑布</button>

  <div class="control-group">
    <label>间距：</label>
    <input type="range" id="spacingSlider" min="0" max="100" value="30" step="5">
    <span id="spacingValue">30 px</span>
  </div>

  <div class="control-group">
    <label>圆角：</label>
    <input type="range" id="radiusSlider" min="0" max="50" value="0" step="2">
    <span id="radiusValue">0 px</span>
  </div>

  <div class="control-group">
    <label>阴影：</label>
    <button id="shadowToggle" onclick="toggleShadow()">开启</button>
  </div>

  <div class="control-group">
    <label>背景色：</label>
    <input type="color" id="bgColor" value="#ffffff">
  </div>

  <button onclick="resetAll()">重置</button>
  <button onclick="exportImage()">保存 PNG</button>
</div>

<div id="container">
  <div id="canvas-wrapper">
    <canvas id="canvas"></canvas>
    <!-- 画布调整手柄 -->
    <div id="handle-t" class="resize-handle"></div>
    <div id="handle-b" class="resize-handle"></div>
    <div id="handle-l" class="resize-handle"></div>
    <div id="handle-r" class="resize-handle"></div>
    <div id="handle-tl" class="resize-handle"></div>
    <div id="handle-tr" class="resize-handle"></div>
    <div id="handle-bl" class="resize-handle"></div>
    <div id="handle-br" class="resize-handle"></div>
  </div>
</div>

<script>
// ==================== 全局状态 ====================
const wrapper = document.getElementById('canvas-wrapper');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let layers = [];  // {type: 'img'|'text', el, img/text, x, y, w, h, rot:0, flipH:1, flipV:1, filter:'none'}
let selected = null;
let isDragging = false, dragOffsetX, dragOffsetY;
let isResizingCanvas = false, resizeDir = '';
let isRotating = false, rotateStartAngle = 0;
let globalMargin = 30;
let globalRadius = 0;
let globalShadow = true;
let bgColor = '#ffffff';

// 防抖函数
function debounce(fn, delay = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
}

const debouncedRearrange = debounce(() => {
  if (layers.length > 0) autoArrange('row');
});

// 初始化画布
function setCanvasSize(w, h) {
  w = Math.max(400, Math.round(w));
  h = Math.max(300, Math.round(h));
  canvas.width = w;
  canvas.height = h;
  wrapper.style.width = w + 'px';
  wrapper.style.height = h + 'px';
}
setCanvasSize(1200, 1200);

// 事件监听
document.getElementById('spacingSlider').addEventListener('input', e => {
  globalMargin = Number(e.target.value);
  document.getElementById('spacingValue').textContent = `${globalMargin} px`;
  debouncedRearrange();
});

document.getElementById('radiusSlider').addEventListener('input', e => {
  globalRadius = Number(e.target.value);
  document.getElementById('radiusValue').textContent = `${globalRadius} px`;
  updateAllStyles();
});

document.getElementById('bgColor').addEventListener('input', e => {
  bgColor = e.target.value;
  wrapper.style.backgroundColor = bgColor;
  wrapper.style.backgroundImage = bgColor === '#ffffff' ? 'linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%), linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%)' : 'none';
});

function toggleShadow() {
  globalShadow = !globalShadow;
  document.getElementById('shadowToggle').textContent = globalShadow ? '开启' : '关闭';
  updateAllStyles();
}

function updateAllStyles() {
  layers.forEach(layer => {
    layer.el.style.borderRadius = `${globalRadius}px`;
    layer.el.style.boxShadow = globalShadow ? '0 4px 12px rgba(0,0,0,0.18)' : 'none';
    if (layer.type === 'img') layer.el.querySelector('img').style.filter = layer.filter || 'none';
  });
}

// 添加图片层
document.getElementById('file').onchange = e => {
  const files = [...e.target.files];
  if (files.length === 0) return;

  let loadedCount = 0;
  const newLayers = [];

  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        const layer = addImageLayer(img, false);
        newLayers.push(layer);
        loadedCount++;
        if (loadedCount === files.length) {
          autoArrange('row', newLayers);
        }
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  });
};

function addImageLayer(img, autoPosition = true) {
  const maxInit = 400;
  const scale = Math.min(maxInit / img.width, maxInit / img.height, 1);
  const w = img.width * scale;
  const h = img.height * scale;

  const el = document.createElement('div');
  el.className = 'layer img-layer';
  el.style.width = w + 'px';
  el.style.height = h + 'px';

  const image = document.createElement('img');
  image.src = img.src;
  image.style.width = '100%';
  image.style.height = '100%';
  image.draggable = false;
  el.appendChild(image);

  const rotateHandle = document.createElement('div');
  rotateHandle.className = 'rotate-handle';
  el.appendChild(rotateHandle);

  wrapper.appendChild(el);

  const layer = { type: 'img', el, img, w, h, rot: 0, flipH: 1, flipV: 1, filter: 'none' };
  layers.push(layer);

  bindLayerEvents(layer);

  if (autoPosition) {
    updateLayerPosition(layer, (canvas.width - w)/2, (canvas.height - h)/2);
    selectLayer(layer);
  }

  updateAllStyles();  // 应用全局样式

  return layer;
}

// 添加文本层
function addTextLayer() {
  const el = document.createElement('div');
  el.className = 'layer text-layer';
  el.contentEditable = true;
  el.textContent = '输入文本';
  el.style.left = '100px';
  el.style.top = '100px';
  el.style.fontSize = '20px';
  el.style.color = '#000';
  el.style.background = 'transparent';

  const rotateHandle = document.createElement('div');
  rotateHandle.className = 'rotate-handle';
  el.appendChild(rotateHandle);

  wrapper.appendChild(el);

  const layer = { type: 'text', el, text: '输入文本', rot: 0 };
  layers.push(layer);

  bindLayerEvents(layer);
  selectLayer(layer);
}

// 绑定层事件（拖拽、旋转、缩放）
function bindLayerEvents(layer) {
  let resizing = false, startW, startH, startX, startY;

  layer.el.addEventListener('pointerdown', e => {
    if (e.target.className === 'rotate-handle') {
      isRotating = true;
      const rect = layer.el.getBoundingClientRect();
      const wrapperRect = wrapper.getBoundingClientRect();
      rotateCenterX = rect.left - wrapperRect.left + rect.width / 2;
      rotateCenterY = rect.top - wrapperRect.top + rect.height / 2;
      rotateStartAngle = Math.atan2(e.clientY - (rect.top + rect.height/2), e.clientX - (rect.left + rect.width/2));
      selectLayer(layer);
      e.stopPropagation();
      return;
    }

    if (layer.type === 'text' && e.target === layer.el) {
      // 允许编辑文本
      return;
    }

    if (e.offsetX > parseFloat(layer.el.style.width) - 40 && e.offsetY > parseFloat(layer.el.style.height) - 40) {
      resizing = true;
      startW = parseFloat(layer.el.style.width);
      startH = parseFloat(layer.el.style.height);
      startX = e.clientX;
      startY = e.clientY;
    } else {
      isDragging = true;
      const rect = layer.el.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      selectLayer(layer);
    }
    e.stopPropagation();
  });

  document.addEventListener('pointermove', e => {
    if (isRotating && selected === layer) {
      const rect = layer.el.getBoundingClientRect();
      const currentAngle = Math.atan2(e.clientY - (rect.top + rect.height/2), e.clientX - (rect.left + rect.width/2));
      const delta = currentAngle - rotateStartAngle;
      layer.rot = (layer.rot + delta * 180 / Math.PI + 360) % 360;
      layer.el.style.transform = `rotate(${layer.rot}deg) scaleX(${layer.flipH}) scaleY(${layer.flipV})`;
      rotateStartAngle = currentAngle;
    } else if (isDragging && selected === layer) {
      const wrapperRect = wrapper.getBoundingClientRect();
      const x = e.clientX - dragOffsetX - wrapperRect.left;
      const y = e.clientY - dragOffsetY - wrapperRect.top;
      layer.el.style.left = Math.max(0, x) + 'px';
      layer.el.style.top = Math.max(0, y) + 'px';
    } else if (resizing && selected === layer) {
      const dx = e.clientX - startX;
      const newW = Math.max(60, startW + dx);
      const ratio = startW / startH;
      layer.el.style.width = newW + 'px';
      layer.el.style.height = (newW / ratio) + 'px';
      if (layer.type === 'img') {
        layer.w = newW;
        layer.h = newW / ratio;
      }
    }
  });

  document.addEventListener('pointerup', () => {
    isDragging = isRotating = resizing = false;
  });
}

// 滚轮缩放
wrapper.addEventListener('wheel', e => {
  e.preventDefault();
  if (!selected) return;
  const delta = e.deltaY > 0 ? 0.92 : 1.085;
  let w = parseFloat(selected.el.style.width) * delta;
  let h = parseFloat(selected.el.style.height) * delta;
  w = Math.max(60, w);
  h = Math.max(60, h);
  selected.el.style.width = w + 'px';
  selected.el.style.height = h + 'px';
  if (selected.type === 'img') {
    selected.w = w;
    selected.h = h;
  }
}, {passive: false});

// 选中层
function selectLayer(layer) {
  document.querySelectorAll('.layer').forEach(el => el.classList.remove('selected'));
  if (layer) layer.el.classList.add('selected');
  selected = layer;
}

function updateLayerPosition(layer, x, y) {
  layer.el.style.left = x + 'px';
  layer.el.style.top = y + 'px';
}

// 翻转选中图片
function flipSelected(direction) {
  if (!selected || selected.type !== 'img') return;
  if (direction === 'horizontal') selected.flipH = -selected.flipH;
  if (direction === 'vertical') selected.flipV = -selected.flipV;
  selected.el.style.transform = `rotate(${selected.rot}deg) scaleX(${selected.flipH}) scaleY(${selected.flipV})`;
}

// 应用滤镜
function applyFilter(filter) {
  if (!selected || selected.type !== 'img') return;
  selected.filter = filter;
  selected.el.querySelector('img').style.filter = filter;
}

// 九宫格排列
function applyNineGrid(targetLayers = layers) {
  if (targetLayers.length === 0) return;

  const margin = globalMargin;
  const gridSize = 3;
  const cellW = (canvas.width - margin * (gridSize + 1)) / gridSize;
  const cellH = (canvas.height - margin * (gridSize + 1)) / gridSize;

  targetLayers.forEach((layer, i) => {
    if (i >= 9) return;

    const row = Math.floor(i / gridSize);
    const col = i % gridSize;

    const x = margin + col * (cellW + margin);
    const y = margin + row * (cellH + margin);

    const el = layer.el;
    const scale = Math.min(cellW / parseFloat(el.style.width), cellH / parseFloat(el.style.height));
    const newW = parseFloat(el.style.width) * scale;
    const newH = parseFloat(el.style.height) * scale;

    el.style.width = newW + 'px';
    el.style.height = newH + 'px';
    updateLayerPosition(layer, x + (cellW - newW)/2, y + (cellH - newH)/2);
  });
}

// 自动排列
function autoArrange(mode = 'row', targetLayers = layers) {
  if (targetLayers.length === 0) return;

  const margin = globalMargin;
  let x = margin, y = margin, rowHeight = 0;
  const maxRowWidth = canvas.width - margin * 2;

  targetLayers.forEach((layer, i) => {
    const el = layer.el;
    let w = parseFloat(el.style.width);
    let h = parseFloat(el.style.height);

    if (mode === 'row') {
      if (x + w + margin > maxRowWidth && i > 0) {
        x = margin;
        y += rowHeight + margin;
        rowHeight = 0;
      }
      updateLayerPosition(layer, x, y);
      x += w + margin;
      rowHeight = Math.max(rowHeight, h);
    } else if (mode === 'waterfall') {
      const col = i % 4;
      const colWidth = (canvas.width - margin * 5) / 4;
      const targetH = 280;
      const scale = targetH / h;
      w = colWidth;
      h = targetH;
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      x = margin + col * (colWidth + margin);
      updateLayerPosition(layer, x, y + (Math.floor(i / 4) * (targetH + margin)));
    }
  });

  const last = targetLayers[targetLayers.length - 1];
  const bottom = parseFloat(last.el.style.top) + parseFloat(last.el.style.height) + margin * 2;
  if (bottom > canvas.height) setCanvasSize(canvas.width, bottom + 200);
}

// 画布调整
const handles = {
  t: document.getElementById('handle-t'),
  b: document.getElementById('handle-b'),
  l: document.getElementById('handle-l'),
  r: document.getElementById('handle-r'),
  tl: document.getElementById('handle-tl'),
  tr: document.getElementById('handle-tr'),
  bl: document.getElementById('handle-bl'),
  br: document.getElementById('handle-br'),
};

Object.entries(handles).forEach(([dir, el]) => {
  el.addEventListener('pointerdown', e => {
    isResizingCanvas = true;
    resizeDir = dir;
    e.stopPropagation();
  });
});

document.addEventListener('pointermove', e => {
  if (!isResizingCanvas) return;
  const rect = wrapper.getBoundingClientRect();
  let newW = canvas.width;
  let newH = canvas.height;

  if (resizeDir.includes('r')) newW = Math.max(400, e.clientX - rect.left + 8);
  if (resizeDir.includes('b')) newH = Math.max(300, e.clientY - rect.top + 8);
  if (resizeDir.includes('l')) newW = Math.max(400, rect.right - e.clientX);
  if (resizeDir.includes('t')) newH = Math.max(300, rect.bottom - e.clientY);

  setCanvasSize(newW, newH);
});

document.addEventListener('pointerup', () => isResizingCanvas = false);

// 导出
function exportImage() {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = canvas.width;
  tempCanvas.height = canvas.height;
  const tctx = tempCanvas.getContext('2d');

  tctx.fillStyle = bgColor;
  tctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

  layers.forEach(layer => {
    const el = layer.el;
    const rect = el.getBoundingClientRect();
    const wrapperRect = wrapper.getBoundingClientRect();
    const x = rect.left - wrapperRect.left;
    const y = rect.top - wrapperRect.top;
    const w = rect.width;
    const h = rect.height;

    tctx.save();
    tctx.translate(x + w / 2, y + h / 2);
    tctx.rotate(layer.rot * Math.PI / 180);
    tctx.scale(layer.flipH || 1, layer.flipV || 1);

    if (globalShadow) {
      tctx.shadowColor = 'rgba(0,0,0,0.18)';
      tctx.shadowBlur = 12;
      tctx.shadowOffsetY = 4;
    }

    if (globalRadius > 0) {
      tctx.beginPath();
      tctx.roundRect(-w / 2, -h / 2, w, h, globalRadius);
      tctx.clip();
    }

    if (layer.type === 'img') {
      tctx.filter = layer.filter;
      tctx.drawImage(layer.img, -w / 2, -h / 2, w, h);
    } else if (layer.type === 'text') {
      tctx.fillStyle = el.style.color;
      tctx.font = `${parseFloat(el.style.fontSize)}px sans-serif`;
      tctx.textAlign = 'center';
      tctx.textBaseline = 'middle';
      tctx.fillText(el.textContent, 0, 0);
    }

    tctx.restore();
  });

  const a = document.createElement('a');
  a.href = tempCanvas.toDataURL('image/png');
  a.download = '拼图.png';
  a.click();
}

// 重置
function resetAll() {
  layers = [];
  wrapper.querySelectorAll('.layer').forEach(el => el.remove());
  setCanvasSize(1200, 1200);
  selected = null;
}
</script>
</body>
</html>
